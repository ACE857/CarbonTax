// From https://github.com/d3/d3-delaunay/blob/master/src/delaunay.js
import Delaunator from "delaunator/delaunator.js";

function pointX(p) {
  return p[0];
}

function pointY(p) {
  return p[1];
} // eslint-disable-next-line max-params


function flatArray(points, fx, fy, that) {
  const n = points.length;
  const array = new Float64Array(n * 2);

  for (let i = 0; i < n; ++i) {
    const p = points[i];
    array[i * 2] = fx.call(that, p, i, points);
    array[i * 2 + 1] = fy.call(that, p, i, points);
  }

  return array;
}

export default class Delaunay {
  // eslint-disable-next-line max-statements
  constructor(points) {
    const {
      halfedges,
      hull,
      triangles
    } = new Delaunator(points);
    this.points = points;
    this.halfedges = halfedges;
    this.hull = hull;
    this.triangles = triangles;
    const inedges = this.inedges = new Int32Array(points.length / 2).fill(-1);
    const outedges = this.outedges = new Int32Array(points.length / 2).fill(-1); // Compute an index from each point to an (arbitrary) incoming halfedge.

    for (let e = 0, n = halfedges.length; e < n; ++e) {
      inedges[triangles[e % 3 === 2 ? e - 2 : e + 1]] = e;
    } // For points on the hull, index both the incoming and outgoing halfedges.


    let node0 = hull;
    let node1 = hull;

    do {
      node0 = node1;
      node1 = node1.next;
      inedges[node1.i] = node0.t;
      outedges[node0.i] = node1.t;
    } while (node1 !== hull);
  }

  neighbors(i) {
    const results = [];
    const {
      inedges,
      outedges,
      halfedges,
      triangles
    } = this;
    const e0 = inedges[i];
    if (e0 === -1) return results; // coincident point

    let e = e0;

    do {
      results.push(triangles[e]);
      e = e % 3 === 2 ? e - 2 : e + 1;
      if (triangles[e] !== i) break; // bad triangulation

      e = halfedges[e];

      if (e === -1) {
        results.push(triangles[outedges[i]]);
        break;
      }
    } while (e !== e0);

    return results;
  }

  find(x, y, i = 0) {
    // eslint-disable-next-line no-self-compare
    if ((x = +x, x !== x) || (y = +y, y !== y)) return -1;
    const i0 = i;
    let c;

    while ((c = this._step(i, x, y)) >= 0 && c !== i && c !== i0) i = c;

    return c;
  }

  _step(i, x, y) {
    const {
      inedges,
      points
    } = this;
    if (inedges[i] === -1) return (i + 1) % (points.length >> 1);
    let c = i;
    let dc = (x - points[i * 2]) ** 2 + (y - points[i * 2 + 1]) ** 2;

    for (const t of this.neighbors(i)) {
      const dt = (x - points[t * 2]) ** 2 + (y - points[t * 2 + 1]) ** 2;

      if (dt < dc) {
        dc = dt;
        c = t;
      }
    }

    return c;
  }

} // eslint-disable-next-line max-params

Delaunay.from = function (points, fx = pointX, fy = pointY, that) {
  return new Delaunay(flatArray(points, fx, fy, that));
}; // only public methods will be .from and .find